
## **类型**
原始类型
*   boolean
*   null
*   undefined
*   number
*   string
*   symbol

引用类型
*   Object

 ## **类型转换**
类型转换分为显式和隐式
```
{}+[] //0
```

## **变量提升**
JavaScript引擎所有的变量的声明语句，都会被提升到代码的头部

## **null与undefined的区别**
* null表示为空，代表此处不应该有值的存在，一个对象可以是null，代表是个空对象，而null本身也是对象。
* undefined表示『不存在』，除了表示存在的空值外，还有可能根本就不存在(因为存不存在只在运行期才知道)。


## **闭包**
* MDN的解释：闭包是函数和声明该函数的词法环境的组合。
闭包最大的作用就是隐藏变量，其特性就是**内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后**，因此JavaScript可以实现私有变量、特权变量、储存变量等。

## **作用域链**
* JavaScript属于静态作用域，即声明的作用域是根据程序正文在编译时就确定的，有时也称为词法作用域。
JavaScript在执行过程中会创造可执行上下文，此词法环境中含有外部词法环境的引用，通过这个引用获取外部的变量、声明等，这些引用串联起来一直指向全局的词法环境，就形成了作用域链。

## **JavaScript的参数传递**
* 由于js中存在**复杂类型**和**基本类型**,对于**基本类型**而言,是按值传递的.

## **箭头函数**
* 箭头函数没有属于自己的this，它的this是捕获其上下文的this，this不会被改变，函数也不会被new调用

## **async/await**
async 函数，就是 Generator 函数的语法糖，它建立在Promises上，并且与所有现有的基于Promise的API兼容。
 async—声明一个异步函数(async function someName(){...})
*   自动将常规函数转换成Promise，返回值也是一个Promise对象
*   只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数
*   异步函数内部可以使用await
await—暂停异步的功能执行(var result = await someAsyncCall()😉
*   放置在Promise调用之前，await强制其他代码等待，直到Promise完成并返回结果
*   只能与Promise一起使用，不适用与回调
*   只能在async函数内部使用

## **async/await相比于Promise的优势**
*   代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调用也会带来额外的阅读负担
*   Promise传递中间值非常麻烦，而async/await几乎是同步的写法，非常优雅
*   错误处理友好，async/await可以用成熟的try/catch，Promise的错误捕获非常冗余
*   调试友好，Promise的调试很差，由于没有代码块，你不能在一个返回表达式的箭头函数中设置断点，如果你在一个.then代码块中使用调试器的步进(step-over)功能，调试器并不会进入后续的.then代码块，因为调试器只能跟踪同步代码的『每一步』。




