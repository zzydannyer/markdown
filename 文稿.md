1. 前端框架的好处

   1. 组件化：高度的组件化可以使我们的工程==易于维护==，易于==组合拓展==
   2. 生态：工具链和UI库都有成熟的解决方案
   3. …

2. 简述前端主流框架

   前端框架

   1. `React`
   2.  `Vue` 
   3. `Angular`
   4.  `Svelte` 
   5. `Solid`
   6.  `Ember`
   7. …

   NodeJS后端框架 

   1. `NestJs`
   2.  `Express` 
   3. `Koa`
   4. …

   全栈开发框架

   1. `Nextjs`
   2.  `Nuxtjs` 
   3. `Remix`
   4. …

   跨平台开发框架

   1. `React Native` 
   2. `Flutter `
   3. `Electron`
   4. `Tauri`
   5. `Taro`
   6.  `Weex`
   7. `Uniapp`
   8. …

   * React ==Class Components== => ==React Hooks==

   ```jsx
   import { Component } from 'react'
   
   class ExampleClass extends Component {
     constructor(props) {
       super(props)
       this.state = {
         count: 1
       }
     }
       
     handleClick = () => {
       let { count } = this.state
       this.setState({
         count: count+1
       })
     }
       
     render() {
       const { count } = this.state
       return (
         <div>
           <p>you click { count }</p>
           <button onClick={this.handleClick}>点击</button>
         </div>
       )
     }
   }
   ```

   ```jsx
   import { useEffect, useState } from 'react'
   
   function usePosition() {
     const [x, setX] = useState(0)
     const [y, setY] = useState(0)
   
     const handleMouseMove = (e) => {
       const { clientX, clientY } = e
       setX(clientX)
       setY(clientY)
     } 
   
     useEffect(() => {
       document.addEventListener('mousemove', handleMouseMove)
       return () => {
         document.removeEventListener('mousemove', handleMouseMove)
       }
     })
     return [
       {x, y}
     ]
   }
   ```

   ```jsx
   // 使用
   function Index() {
     const [position] = usePosition()
     return(
       <div>
         <p>x:{position.x},y:{position.y}</p>
       </div>
     )
   }
   ```

   可以很明显的看出使用hooks对逻辑复用更加的方便，使用的时候逻辑也更加清晰，Vue3 Composition API（组合式API）就是受此影响诞生的

3. 技术栈

   路由管理库： Vue-router

   状态管理库： Pinia、 Vuex

   UI框架：[Element Plus](https://link.juejin.cn/?target=https%3A%2F%2Felement-plus.org%2F)、[Ant Design Vue](https://link.juejin.cn/?target=https%3A%2F%2Fwww.antdv.com%2F)、[Quasar](https://link.juejin.cn/?target=https%3A%2F%2Fquasar.dev%2F)、[Vuetify](https://link.juejin.cn/?target=https%3A%2F%2Fnext.vuetifyjs.com%2Fen%2Fgetting-started%2Finstallation%2F)、[Naive UI](https://link.juejin.cn/?target=https%3A%2F%2Fwww.naiveui.com%2Fen-US%2Fos-theme)、[Prime Vue](https://link.juejin.cn/?target=https%3A%2F%2Fwww.primefaces.org%2F)

   移动端： [Ionic](https://link.juejin.cn/?target=https%3A%2F%2Fionicframework.com%2F)、[Vant](https://link.juejin.cn/?target=https%3A%2F%2Fyouzan.github.io%2Fvant%2F%23%2Fen-US)、[Varlet](https://link.juejin.cn/?target=https%3A%2F%2Fmadewithvuejs.com%2Fvarlet-ui)、[NutUI](https://link.juejin.cn/?target=https%3A%2F%2Fnutui.jd.com%2F%23%2Fstart)、[WaveUI](https://link.juejin.cn/?target=https%3A%2F%2Fantoniandre.github.io%2Fwave-ui%2F)

   构建工具：Vite、VueCli、Webpack

   工具库： [VueUse](https://vueuse.org)、[unplugin-vue-components](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Funplugin-vue-components)、[vuex-persistedstate](https://link.juejin.cn/?target=https%3A%2F%2Fchampionswimmer.in%2Fvuex-persist%2F)、[pinia-plugin-persistedstate](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fprazdevs%2Fpinia-plugin-persistedstate)、

   [vue-cropper](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frobinvdvleuten%2Fvuex-persistedstate)、[vue-print-nb](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FPower-kxLee%2Fvue-print-nb)、[vue-multiselect-next](https://link.juejin.cn/?target=https%3A%2F%2Fvue-multiselect.js.org%2F)…

   调试工具：Vue Devtools

   单测工具：Vitest、Jest

4. Vue2 & 3 的区别

   1. 兼容性：Vue2不兼容IE8及以下的版本，Vue3不兼容IE
   2. Vue3依然可以使用大部分optionsAPI
      1. Vue3对比Vue2具有明显的性能提升
         - 打包大小减少41%
         - 初次渲染快55%，更新快133%
         - 内存使用减少54%
      2. Vue3具有的composition API实现逻辑模块化和重用
   3. Object.defineProperty 和 Proxy
   4. Vue2响应式缺点
      1. 无法检测对象属性的添加或移除。
      2. 无法检测按索引更新数组

   1. 单节点多节点

   2. 视图更新

   3. mixins和hooks

      1. mixins不清晰数据来源，同名会被覆盖，mixins之前数据流动不明，很难排查
      2. hooks更清晰，不会出现冲突问题

   4. 生命周期

      ```js
      beforeCreate -> setup()
      
      created -> setup()
      
      beforeMount -> onBeforeMount
      
      mounted -> onMounted
      
      beforeUpdate -> onBeforeUpdate
      
      updated -> onUpdated
      
      beforeDestroy -> onBeforeUnmount
      
      destroyed -> onUnmounted
      ```

   5. attrs 和 listeners （privide inject）