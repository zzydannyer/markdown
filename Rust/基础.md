### 栈

栈是程序运行的基础。每当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为帧（frame）。

**在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上。**比如一个函数，参数是字符串

>  ==**栈溢出（stack overflow）**==。一旦当前程序的调用栈超出了系统允许的最大栈空间，无法创建新的帧，来运行下一个要执行的函数，就会发生栈溢出，这时程序会被系统终止，产生崩溃信息。



### 堆

**当我们需要动态大小的内存时，只能使用堆**，比如可变长度的数组、列表、哈希表、字典，它们都分配在堆上。

栈上的内存在函数调用结束之后，所使用的帧被回收，相关变量对应的内存也都被回收待用。所以栈上内存的生命周期是不受开发者控制的，并且局限在当前调用栈。

而堆上分配出来的每一块内存需要显式地释放，这就使**堆上内存有更加灵活的生命周期，可以在不同的调用栈之间共享数据。**

> 如果手工管理堆内存的话，堆上内存分配后忘记释放，就会造成==**内存泄漏**==。一旦有内存泄漏，程序运行得越久，就越吃内存，最终会因为占满内存而被操作系统终止运行。
>
> 如果堆上内存被多个线程的调用栈引用，该内存的改动要特别小心，需要加锁以独占访问，来避免潜在的问题。比如说，一个线程在遍历列表，而另一个线程在释放列表中的某一项，就可能访问野指针，==**导致堆越界（heap out of bounds）**==。而堆越界是第一大内存安全问题。
>
> 如果堆上内存被释放，但栈上指向堆上内存的相应指针没有被清空，就有可能发生==**使用已释放内存（use after free）**==的情况，程序轻则崩溃，重则隐含安全隐患。这是第二大内存安全问题。

#### 总结

<u>**栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期**</u>

对于存入栈上的值，它的大小在编译期就需要确定。栈上存储的变量生命周期在当前调用栈的作用域内，无法跨调用栈引用。

堆可以存入大小未知或者动态伸缩的数据类型。堆上存储的变量，其生命周期从分配后开始，一直到释放时才结束，因此堆上的变量允许在多个调用栈之间引用。但也导致堆变量的管理非常复杂，手工管理会引发很多内存安全性问题，而自动管理，无论是 GC 还是 ARC，都有性能损耗和其它问题。



### 数据

数据是程序操作的对象，不进行数据处理的程序是没有意义的，**数据包括值和类型、指针和引用**。



#### 值和类型

类型是对值的区分，它包含了值在内存中的**长度、对齐以及值可以进行的操作**等信息。

值是符合一个特定类型的数据的某个实体，以类型规定的表达方式（representation）被存储成一组字节流进行访问。

**值是无法脱离具体的类型讨论的。**同样是内存中的一个字节 0x40，如果其类型是 ASCII char，那么其含义就不是 64，而是 @ 符号。

原生类型（primitive type）是编程语言提供的最基础的数据类型。比如==字符==、==整数==、==浮点数==、==布尔值==、==数组==（array）、==元组==（tuple）、==指针==、==引用==、==函数==、==闭包==等。所有原生类型的大小都是固定的，因此它们可以被分配到栈上。

组合类型（composite type）或者说复合类型，是指由一组原生类型和其它类型组合而成的类型。组合类型也可以细分为两类：

* 结构体（structure type）：多个类型组合在一起共同表达一个值的复杂数据结构。比如 Person 结构体，内部包含 name、age、email 等信息。用代数数据类型（algebraic data type）的说法，结构体是 product type。

* 标签联合（tagged union）：也叫不相交并集（disjoint union），可以存储一组不同但固定的类型中的某个类型的对象，具体是哪个类型由其标签决定。比如 Haskell 里的 Maybe 类型，或者 Swift 中的 Optional 就是标签联合。用代数数据类型的说法，标签联合是 sum type。



#### 指针和引用

**指针和引用是原生类型，它们可以分配在栈上**

在内存中，一个值被存储到内存中的某个位置，这个位置对应一个内存地址。而指针是一个持有内存地址的值，可以通过解引用（dereference）来访问它指向的内存地址，理论上可以解引用到任意数据类型。

引用（reference）和指针非常类似，不同的是，引用的解引用访问是受限的，它只能解引用到它引用数据的类型，不能用作它用。

### 代码

数据是程序操作的对象，而代码是程序运行的主体，也是我们开发者把物理世界中的需求转换成数字世界中逻辑的载体。如**函数和闭包、接口和虚表**。



#### 函数、方法和闭包

**函数是编程语言的基本要素，它是对完成某个功能的一组相关语句和表达式的封装**。函数也是对代码中重复行为的抽象，可以作为参数传递，或者作为返回值返回，也可以作为复合类型中的一个组成部分。

在面向对象的编程语言中，在类或者对象中定义的函数，被称为方法（method）

闭包是将函数，或者说代码和其环境一起存储的一种数据结构。**闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分。**



#### 接口和虚表

接口是一个软件系统开发的核心部分，它反映了系统的设计者对系统的抽象理解。作为一个抽象层，**接口将使用方和实现方隔离开来，使两者不直接有依赖关系，大大提高了复用性和扩展性。**

当我们在运行期使用接口来引用具体类型的时候，代码就具备了运行时多态的能力。但是，在运行时，一旦使用了关于接口的引用，变量原本的类型被抹去，我们无法单纯从一个指针分析出这个引用具备什么样的能力。因此，在**生成这个引用的时候，我们需要构建胖指针，除了指向数据本身外，还需要指向一张涵盖了这个接口所支持方法的列表。这个列表，就是我们熟知的虚表（virtual table）。**



### 运行方式

程序在加载后，代**码以何种方式运行，往往决定着程序的执行效率。**所以我们接下来讨论并发、并行、同步、异步以及异步中的几个重要概念 Promise/async/await。

#### 并发concurrency & 并行 parallel

在代码的运行方式中，**并发是并行的基础，是同时与多个任务打交道的能力；并行是并发的体现，是同时处理多个任务的手段。**



#### 同步异步

同步阻塞后续操作，异步允许后续操作。被广泛用于异步操作的 Promise 代表未来某个时刻会得到的结果，async/await 是 Promise 的封装，一般用状态机来实现。

* 异步状态：
  1. 初始状态，Promise 还未运行；等待（pending）状态
  2. Promise 已运行，但还未结束；
  3. 结束状态， Promise 成功解析出一个值，或者执行失败。



### 编程范式

为了在不断迭代时，更好地维护代码，我们还会引入各种各样的编程范式，来提升代码的质量。



#### 泛型编程

通过参数化让数据结构像函数一样延迟绑定，提升其通用性，类型的参数可以用接口约束，使类型满足一定的行为，同时，在使用泛型结构时，我们的代码也需要更高的抽象度。